Constraints:
-Rule/condition which is applied while creating a table.
-It is not mandatory(but highly recommended)
-Used to restrict the data that are entering into table.
-Here, constraints are applied in column level.
Note:-
-Null means empty space.
-Inside the cell, if we see an empty space, it will be considered as null.
Types of constraints:
1)not null
2)unique
3)Primary key
4)Foreign key
5)check
6)default

1/-not null: Used to avoid null values.
-While inserting the data into the column user must and should pass the values.(it wont take any null values)

2/-unique: It avoids duplicate values.
-User can not insert/store same values into that particular column.
-Unique can take more than one null values on oracle 10g but not on MySQL.(MySQL DB allows only one value for unique column).
		  
3/-Primary Key: Combination of unique and not null.
-For one table we can have only one primary key, more than one primary key is not allowed by the server.
-Used for unique identification of each record.(***)
-Primary Key is not mandatory but highly recommended.
ex: rollno number(4) primary key

4/-Foreign key: Used to build a relation from one table to another table.(to establish some parent-child relation)
-In a table we can have more than one foreign key.
-Foreign Key is also known as referential-integrity constraints.
-Foreign key allows duplicates and null values.
-Primary key of the parent table should be the foreign key in child table.
ex: tid, hid are the foreign key
				
5/-Check:Used to restrict the data that is entering into the table-column.
-It is like a rule given to the particular column, if the rule or given condition is satisfied it allows the data to be stored else it rejects.
ex: phono number(10) check (length(phno)=10)

6/-Default: Used to store the default value for a given column.
ex: Branch varchar2(10) default "MECH"

Create a copy of table.
Syntax:
Create table table-name as select statement;
ex: create table emp1 as select * from emp;

DML(Data Manipulation Language):
-Used to manage and manipulate the data inside the database.
-DML is not directly connecteed to database, so the changes are not permanent.
-DML commands are not auto-commited.
-To make the changes permanent to database we should use TCL.

1)insert: Used to insert the values into the table.
Syntax: 1(if you want store all the values into all the columns for particular row)
insert into table-name values (value1, value2, value3.....);
ex:insert into product1 values (1,'car',1200,12-sep-2022);

syntax2:(if you want to store the values for particular column use syntax2)
insert into table-name (col1, col2, col3.....) values (value1, value2, value3.....) ;
ex: insert into product1 (pid,pname) values(1,bus);

TCL:Used to control the transaction done by the DML statement.
-TCL are applicable only for DML statement.

commit: used to save the data permanently into the database.
syntax: commit;

DQL: Data Query Language
-Used to retreive the data from the Database.
-select : Used to retreive/select the data from the table/database and to display it.
-The returned rows may be set of rows stored in a table called result table or result set.
-To retreive the data we have three different ways:
1)projection
2)selection
3)joins

																	
Projection: Used to retreive the data just by selecting the column is known as projection.
syntax: select */distinct column-name expression/aliasing
        from table-name;
order of execution: 1)from
					2)select
note: * selects all the column, once the column is selected by default values get selected.
-If user gives the table-name which is not present in the database, then user gets an error(table/view dosen't exist,)
-If user gives the col-name which is not present in the table, then user gets an error as invalid-identifier.
-Query: its a request sent to database to fetch the required data.

Q1)WAQTD details of employee.
ans- select * from emp;
Q2)WAQTD details of department.
ans- select * from dept;
Q3)WAQTD salgrade details.
ans- select * from salgrade;

Distinct: Used to remove the duplicate in specified column or in table.
-We can include more than one column in one distinct keyword/clause.
-We cannot have more than one distinct in one select statement.
-If the user has a requirement of using distinct, always the distinct should be the 1st argument after the select clause.

Q4)WAQTD employee name and salary of all the employee.
ans- select ename,sal from emp;
Q5)WAQTD employee name, salary, mgr, comm and deptno of all employee.
ans- select ename,sal,mgr,comm,deptno from emp;
Q6)WAQTD unique jobs.
ans- select distinct job from emp;
Q7)WAQTD unique deptno.
ans- select distinct deptno from emp;
Q8)WAQTD unique job, deptno of employee.
ans- select distinct job,deptno from emp;

Expression/aliasing:
Expression: Combination of operand and operator.

Aliasing: Used to rename the column-name.
-Aliasing can be done in 3 ways.
		1)using as keyword
		2)using space( )
		3)using double quote("")
1)old-column-name as aliasing-name
2)old-col-name aliasing-name
2)old-column-name "aliasing-name" (if you want space inside single column use the 3rd way(""))

Q9)WAQTD all the details of employee along with annualsal.
ans- select emp.*,sal*12 as annualsal from emp;
Q10)WAQTD all the details of employee along with their half term salary and anual salary.
ans- select emp.*,sal*6 "HALF TERM SAL",sal*12 "ANUAL SAL" from emp;
Q11)WAQTD empno as eid, sal as salary and deptno as dno.
ans- select empno eid,sal as salary,deptno "DNO" from emp;
														
Selection: Used to retreive the data by selecting nth columns and rows is known as selection.
syntax- select */distinct column-name expression/aliasing
		from table-name
		where <condition>;

Order of execution: from
					where
					select

Note: Where clause: used to filter the records inside the table.
-Where clause executes row by row process.
-we can write n number of conditon inside the where clause.
-We cannot write more than one where clause in one select statement.
-Where clause is implimented on rows.

**- If the condition is not satisfied in any of the row, we get the output as no rows selected.(If the given condition are false)
-In the selection, select is dependent on the where clause.(filtered rows)

Q1)WAQTD details of MARTIN.
ans- select * from emp where ename='MARTIN';
o/p- (1)no of rows
Q2)WAQTD details of employee who works as CLERK.
ans- select * from emp where job='CLERK';
o/p- (4)no of rows
Q3)WAQTD details of employee who are earning 3000.
ans- select * from emp where sal=3000;
o/p- (2)no of rows
Q4)WAQTD ename and deptno, if the employee works in deptno 30.
ans- select ename,deptno from emp where deptno=30;
o/p- (6)no of rows
Q5)WAQTD ename and hiredate, if employee hired on '03-DEC-81'.
ans- select ename, hiredate from emp where hiredate='03-DEC-81';
o/p- (2)no of rows
Q6)WAQTD employee name, salary and mgr, if employee reporting manager number is 7839.
ans- select ename,sal,mgr from emp where mgr=7839;
o/p- (3)no of rows 
Q7)WAQTD details of employee who earns commision more than 400.
ans- select * from emp where comm>400;
o/p- (2)no of rows
Q8)WAQTD details of employee, if employee number is 7902.
ans- select * from emp where empno=7902;
o/p- (1)no of rows
Q9)WAQTD details of employee along with annualsal, if annualsal is 36000.
ans- select emp.*,sal*12 as annualsal from emp where sal*12=36000;
o/p- (2)no of rows
Q10)WAQTD details of employee along with halfterm salary, if halfterm salary of employee is 40000.
ans- select emp.*,sal*6 as halfterm from emp where sal*6=40000;
o/p- (0)no of rows	


OPERATORS:
-Operator is uesd to perform operation between operands.
Types of Operators:
1)Arithmatic operator:(+,-,*,/)
2)Relational/Comparision operator:(>,<,>=,<=,!=(<>))
3)Special operator: is,is not,in,not in,like,not like,between,not between.

1)Arithmatic operator: 
----------------------
-Used to perform arithmatic operation between the operand.

Q1)WAQTD employee name,sal and also display the salary after 10% hike.
ans- select ename,sal,sal+sal*10/100 as hike from emp;
o/p- (14)no rows selected
Q2)WAQTD employee name,sal and also display the salary after 20% deduction.
ans- select ename,sal,sal-sal*20/100 as deduction from emp;
o/p- (14)no rows selected
Q3)WAQTD employee name,sal and also display the salary after 10% hike,also display their names if and only if the hiked salary is more than 20000.
ans- select ename,sal,sal+sal*10/100 as hike from emp where sal+sal*10/100>20000;
o/p- no rows selected

Relational operator: 
--------------------
-Used to compare the given operands.(<,>,<=,>=,!=(<>))
Q1)WAQTD employee details, if employee earn more than 3000.
ans- select * from emp 
	 where sal>3000;
Q2)WAQTD employee details, if employee earn less than 1000.
ans- select * from emp 
	 where sal<1000;
Q3)WAQTD employee details, except who are working in deptno 10.
ans- select * from emp 
	 where deptno != 10;
Q4)WAQTD employee details, except who works as ANAYST.
ans- select * from emp 
	 where job != 'ANAYST';
Q5)WAQTD employee details, except whoes mgr number is 7698.
ans- select * from emp 
	 where mgr !=7698;
Q6)WAQTD employee details, if employee working as manager.
ans- select * from emp 
	 where job = 'MANAGER';
Q7)WAQTD employee details, if employee earning 3000 or more than 3000.
ans- select * from emp 
	 where sal>= 3000;

Logical Operator:
----------------
AND: 
-If all the conditions are true, it returns true(select the records) else false(reject the records)

Q1)WAQTD employee name, sal and deptno, if employee earning more than 2000 and works in deptno 10.
ans- select ename,sal,deptno 
	 from emp 
	 where sal>2000 and deptno=10;
Q2)WAQTD employee details, if employee number is 7902 and also works as SALESMAN.
ans- select * from emp 
	 where empno=7902 and  job = 'SALESMAN';
Q3)WAQTD employee details, if employee mgr number is 7839 and also comm is more than 300.
ans- select * from emp 
	 where mgr = 7839 and comm>300;
Q4)WAQTD employee details, if employee hired on 03-DEC-81 and works in deptno 10.
ans- select * from emp 
	 where hiredate='03-DEC-81' and deptno=10;
Q5)WAQTD employee details, if employee working as ANAYST in deptno 20.
ans- select * from emp 
	 where job='ANAYST' and deptno=20;
Q6)WAQTD employee details, if employee earn more than 1000 but less than 3000.
ans- select * from emp 
	 where sal>1000 and sal<3000;

OR: 
-If any of the condition is true, it returns true.

Q1)WAQTD employee details, if employee works in deptno 10 or 20 or 30 or 40.
ans- select * from emp where deptno=10 or deptno=20 or deptno=30 or deptno=40;
Q2)WAQTD employee name, sal and job works as SALESMAN or MANAGER.
ans- select ename,sal,job from emp where job='SALESMAN' or job='MANAGER';
Q3)WAQTD employee name,sal,mgr,deptno and job, if employee name is SMITH or MILLER.
ans- select ename,sal,mgr,deptno,job from emp where ename='SMITH' or ename='MILLER';
Q4)WAQTD employee number,name and job, if employee num ber is 7566 or 7902.
ans- select empno,ename,job from emp where empno=7566 or empno=7902;
Q5)WAQTD employee name, if employee mgr is 7839 or 7639.
ans- select ename from emp where mgr=7839 or mgr=7639;

Combination of (AND,OR)
Q1)WAQTD employee name, sal, deptno and job works as ANAYST and also in deptno 10 or 20.
ans- select ename,sal,deptno,job 
	 from emp 
	 where job='ANALYST' and (deptno=10 or deptno=20);
	 
Q2)WAQTD employee name, sal, deptno and job, if employee earning more than 3000 as clerk or salesman or manager.
ans- select ename,sal,deptno,job 
	 from emp 
	 where sal>3000 and (job='CLERK' or job='SALESMAN' or job='MANAGER');
	 
Q3)WAQTD employee name, sal and job works as analys or president on deptno 10 or 20 and also employee mgr number is 7839.
ans- select ename,sal,job
	 from emp 
	 where (job='ANAYST' or job='PRESIDENT') and (deptno=10 or deptno=20) and mgr=7839;
	 
Q4)WAQTD employee details, if employee earn less than 3000 but works in deptno 20 or 30 and also except who works as MANAGER or PRESIDENT.
ans- select * from emp 
	 where sal<3000 and (deptno=20 or deptno=30 or deptno=30) and (job!='MANAGER' and job!='PRESIDENT');

NOT:
-Used to give the opposite values.
Syntax: not column-name='VALUE';

Q1)WAQTD employee details, except employee who works in deptno 20.
ans- select * from emp 
	 where not deptno = 20;
o/p- 9 rows
Q2)WAQTD employee details, except employee who works as clerk also except salesman.
ans- select * from emp 
	 where not job = 'CLERK' and not job= 'SALESMAN';
o/p- 6 rows
Q3)WAQTD employee name and salary, except who are earning more than 3000.
ans- select ename,sal 
	 from emp 
	 where not sal>3000;
o/p- 13 row

Combination(AND,OR,NOT):
Q1)WAQTD employee name,sal and deptno, if employee earning more than 2000 but less than 4000 and working as clerk or salesman except whoes deptno is 20.
ans- select ename,sal,deptno 
	from emp 
	where sal>2000 and sal<4000 and (job='CLERK' or job='SALESMAN') and not deptno=20;
o/p- 0 rows
Q2)WAQTD employee name,sal,job and deptno, if employee work in deptno 10 or 20, as clerk or manager except smith and allen.
ans- select ename,sal,job,deptno
	 from emp
	 where (deptno=10 or deptno=20) and (job='CLERK' or job='MANAGER') and not(ename='SMITH' or ename='ALLEN');
o/p- 4 rows
Q3)WAQTD employee details, if employee earn more than 3000 and also works as president in deptno 10 or 20, except martin and miller.
ans- select * from emp
	 where sal>3000 and job='PRESIDENT' and (deptno=10 or deptno=20) and not(ename='MARTIN' or ename='MILLER');
o/p- 1 rows

Date :
When we deal with dates we have to follow this-
1)on =
2)before <
3)after >
4)from >=

Q1)WAQTD employee details, if employee hired on '23-JAN-82'.
ans- select * from emp
	 where hiredate='23-JAN-82';
o/p- 1 row
Q2)WAQTD employee details, if employee hired after '03-DEC-81'.
ans- select * from emp
	 where hiredate>'03-DEC-81';
o/p- 3 rows
Q3)WAQTD employee details, if employee hired after year 81.
ans- select * from emp
	 where hiredate > '31-DEC-81';
o/p- 3 rows
Q4)WAQTD employee details, if employee hired after year 83 and works in deptno 10 or 20.
ans- select * from emp
	 where hiredate>'31-DEC-83' and (deptno=10 or deptno=20);
o/p- 2 rows
Q5)WAQTD employee details, if employee hired before year '10-JAN-81'.
ans- select * from emp
	 where hiredate <'10-JAN-81';
o/p- 1 row
Q6)WAQTD employee details, if employee hired before year 85 and works as clerk or manager in deptno 10 or 20.
ans- select * from emp
	 where hiredate<'01-JAN-85' and (job='CLERK' or job='MANAGER') and (deptno=10 or deptno=20);
o/p- 4 rows
Q7)WAQTD employee details, if employee hired after year 81 but hired before year 85.
ans- select * from emp
	 where hiredate>'31-DEC-81' and hiredate<'01-JAN-85';
o/p- 1 row
Q8)WAQTD employee details, if employee hired from 81 and except salesman.
ans- select * from emp
	 where hiredate>='01-JAN-81' and not job='SALESMAN';
o/p- 9 rows

Special Operator:
-----------------
IS:
-Used to evalute null values inside the specific column.
syntax: column-name is null;

Q1)WAQTD employee details, if employee dont have any reporting manager.
ans- select * from emp
	 where mgr is null;
o/p- 1 row
Q2)WAQTD employee name,sal and comm, if employee not earning any commission.
ans- select ename,sal,comm 
	 from emp
	 where comm is null;
o/p- 10 rows
Q3)WAQTD employee details, who are not working in any dept.
ans- select * from emp
	 where deptno is null;
o/p- 0 rows
Q4)WAQTD employee details, except employee who work as clerk also except salesman and employee's dont earn any commission.
ans- select * from emp
	 where not (job='CLERK' or job='SALESMAN') and
	 comm is null;
o/p- 6 rows

IS NOT:
-Used to evalute not null values.
Syntax: column-name is not null;

Q1)WAQTD employee details who are earning some salary in deptno 10.
ans- selected * from emp 
	 where sal is not null and deptno = 10;
o/p- 3 rows
Q2)WAQTD employee details who have reporting manager.
ans- select * from emp 
	 where mgr is not null;
o/p- 13 rows
Q3)WAQTD employee details, who are earning some commission.
ans- select * from emp
	 where comm is not null;
o/p- 4 rows

IN:
-Used to evalute multiple values in specified column.
-It selects the data or values given in RHS.
Syntax: column-name in (value1,value2...);

Q1)WAQTD employee details, if employee works in dept 10 or 20.
ans- select * from emp
	 where deptno in(10,20);
o/p- 8 rows
Q2)WAQTD employee name and sal, if employee name is SMITH or ALLEN or MARTIN.
ans- select ename,sal from emp
	 where ename in ('SMITH','ALLEN','MARTIN');
o/p- 3 rows
Q3)WAQTD employee details, if employee earning more than 2000 but less than 5000, as analyst or manager in deptno 20 or 30 and also hired after year 81.
ans- select * from emp
	 where sal>2000 and sal<5000 and job in ('ANAYST','MANAGER') and deptno in (20,30) and hiredate>'31-DEC-81';
o/p- no rows selected / 1
Q4)WAQTD employee name and deptno, if employee is working in dept 10 or 20 or 30 or 40 or 50.
ans- select ename,deptno from emp 
	 where deptno in(10,20,30,40,50);
o/p- 14 rows 

NOT IN: Used to evalute multiple values in a specific column.
-It rejects the values given in RHS and selects all the other values in specified column.
-In LHS pass 1 argument, RHS we can pass one or more values.
Syntax: column-name not in (value1,value2.....);

Q1)WAQTD employee details, except who works in deptno 10 and 20.
ans- selected * from emp
	 where deptno not in(10,20);
o/p- 6 rows
Q2)WAQTD employee details, except clerk,manager,analyst and salesman.
ans- select * from emp
	 where job not in('CLERK','MANAGER','ANAYST','SALESMAN');
o/p- 3 rows / 1
Q3)WAQTD employee name,sal,deptno and job,except clerk and salesman, also except who works in deptno 10 and 30.
ans- select ename,sal,deptno,job from emp
	 where job not in('CLERK','SALESMAN') and deptno is not null and deptno not in (10,30);
o/p- 3 rows
Q4)WAQTD employee details, who are not earning any commission but works in some department as clerk or salesman, except employee's who works in deptno 20 and 30.
ans- select * from emp 
	 where comm is null and job in('CLERK','SALESMAN')and deptno not in(10,20);
o/p- 1 row

BETWEEN:
-Used for range purpose.
Syntax: column-name between value1 and value2;

value1 and value2 are given ranges.
(value1 is lower range, value2 is higher range)

Q1)WAQTD employee name nad sal, if employee earning 1000 to 3000.
ans- select ename,sal from emp 
	 where sal between 1000 and 3000;
o/p- 11 rows
Q2)WAQTD employee name and hiredate, if employee hiredate from year 81 to year 85.
ans- select ename,hiredate from emp 
	 where hiredate between '01-JAN-81' and '31-DEC-85' ;
o/p- 11 rows
Q3)WAQTD employee name and  hiredate, if employee hired from year 80 to year 81 or from year 85 to year 87.
ans- select ename,hiredate from emp 
	 where (hiredate between '01-JAN-80' and '31-DEC-81') or (hiredate between '01-JAN-85' and '31-DEC-87');
o/p- 13 rows

NOT BETWEEN:
-Opposite to between operator.
Syntax: column-name not between value1 and value2;

Q1)WAQTD employee name and sal, except who are earning from 1000 to 3000.
ans- select ename,sal from emp 
	 where sal not between 1000 and 3000;
o/p- 3 rows
Q2)WAQTD employee name and hiredate, except who are hired from year 81 to year 85.
ans- select ename,hiredate from emp 
	 where hiredate not between '01-JAN-81' and '31-DEC-85' ;
o/p- 3 rows


LIKE:
-Used for pattern matching.
There are 2 wildcards:
1)_ :Which takes 1 character.
2)% :Which may take zero, 1 or more character.

Syntax: where column-name like 'Pattern';

Q1)WAQTD employee name, if employee name starts with character 'A'.
o/p- 2 rows
Q2)WAQTD employee name, if employee name starts with character 'S'.
o/p- 2 rows
Q3)WAQTD employee name, if employee name starts with character 'A' or 'M'.
o/p- 4 rows
Q4)WAQTD employee name, if employee name starts with character 'A' but end with 'M'.
o/p- no rows selected
Q5)WAQTD employee name, if employee name contains at least 1 'A'.
o/p- 7 rows selected
Q6)WAQTD employee name, if employee name contains at least 2 'A'.
o/p- 1 row
Q7)WAQTD employee name and sal, if employee name contains exactly 4 characters.
o/p- 3 rows
Q8)WAQTD employee name and sal, if employee name last 2nd character is 'E'and their salary ends with 0.
o/p- 4 rows 
Q9)WAQTD employee name, if employee name contains two consecutive L.
o/p- 2 rows
Q10)WAQTD employee name, if employee name starting 3rd character is 'M' and works in dept 10 or 20.
o/p- no rows selected
Q11)WAQTD employee name and hiredate, if employee hired in FEB.
o/p- 2 rows
Q12)WAQTD employee name and hiredate, if employee hired in year 81.
o/p- 10 rows selected
Q13)WAQTD employee name and job, if employee name starts with 'A' and their job starts with 'S'.
o/p- 1 row
Q14)WAQTD employee details, if employee name starts with vowels.
o/p- 2 rows 
Q15)WAQTD employee details, if employee name ends with vowels.
o/p- 1 row
Q16)WAQTD employee name, if employee name contains @.
ans- select * from emp 
	 where ename like '%@%';
o/p- no rows selected

NOTE:
If we want to find the _ or % in a given names, we have to make use of escape.
ex: select ename from emp
	where ename like '%@_%' escape '@';

NOT LIKE:
-It is just opposite to like operator.
-Instead of selecting the pattern, it is going to reject the given pattern.
Syntax: column-name not like 'pattern';

Q1)WAQTD employee name, except employees whoes name starting with 'A'.
ans- select ename from emp
	 where ename not like 'A%';
o/p- 12 rows selected
Q2)WAQTD employee name, except employees whoes name ending with 'R'.
o/p- 12 rows selected
Q3)WAQTD employee name, except employees whoes name starting with 'A' also except employees whoes name starting with 'S'.
o/p- 10 rows selected
Q4)WAQTD employee name, except employees whoes name contains at least 1 'A'.
o/p- 7 rows selected
Q5)WAQTD employee name, except employees whoes name starting with 'A' and ending with 'S'.
o/p- 13 rows selected
Q6)WAQTD employee name and hiredate, except employees who hired in DEC.
o/p- 11 rows selected
Q7)WAQTD employee name and salary, except whoes salary ending with 0.
o/p- 1 row
Q8)WAQTD employee name, if employee name starting with consonants.
o/p- 12 rows selected
Q9)WAQTD employee name, if employee name ending with consonants.
o/p- 13 rows selected
Q10)WAQTD employee name, except employees whoes name starting with consonants also except whoes name ending with vowels.
o/p- 2 rows

-:Functions:-
----------	-------------
-Set of instruction which is used to perform some specific task.

Function contains:
1)Function name
2)Number of arguments
3)Return type

There are two types of function:
1)SRF(Single row function)
2)MRF(Multi roe function)

1)SRF():
-It takes n no. of inputs and executes and produce n nu. of output.
-Single row function can be used in 
	select
	where
	order by

Types of SRF():
1)Character Function
2)Number Function
3)Date Function
4)Special Function

Character Function:
-It takes character(alphanumeric) input and produce the output either alphabets or numbers.

upper():- Used to convert the data into uppercase.
Syntax: upper(arg1)

Q1)WAQTD to convert all the employee names into upper case.
ans- select upper(ename) from emp;
Q2)WAQTD to convert all the employee name s and job into upper case.
Q3)WAQTD to convert jspider into upper case.

NOTE:
-Dual table is dummy table present iside the database, with 1 row 1 column, by default it contains value X with varchar2(1) type.

lower():- Used to convert the data into lowercase.
Syntax: lower(arg1)

Q1)WAQTD to convert all the employee names into lowercase.
ans- select lower(ename) from emp;
Q2)WAQTD to convert jspider into lowercase.
Q3)WAQTD details of employee SMITH.(with irrespective of case)

initcap():- Used to convert all the words 1st character as uppercase.
Syntax: initcap(arg1)
ex- select initcap('you are beautiful') from dual;
o/p- You Are Beautiful

Character Manipulation:-
length():- It is used to display the number of characters present in the given data.
Syntax: length(arg1)

Q1)WAQTD employee name and also no. of characters present in their names.
ans- select ename, length(ename) from emp;
Q2)WAQTD employee details if the employee name exactly contains 5 characters in their name.
o/p- 8 rows selected
Q3)WAQTD employee name and no of characters present in their name for allen and ward.
Q4)WAQTD employee names whoes length is 4 or 5.
o/p- 11 rows selected

reverse():- Used to reverse the given data.
Syntax: reverse(arg1)

Q1)WAQTD to reverse all the employee name.
ans- select reverse(ename) from emp; 
Q2)WAQTD to reverse WebBocket.

Q3)WAQTD the reverse of your name.


concat():- Used to merger the given string or data.
Syntax: concat(arg1,arg2)
-concat operator (||) can be used in select clause.

Q1)WAQTD 'hi' before all the employee names.
ans- select concat('Hi',ename) from emp;
Q2)WAQTD 'hi' before all the employee names along with display 'your designation is', particular designation must displayed.
Q3)WAQTD 'hi' for all the employee name and also display 'your salary is hiked upto 10%' with 10% salary must be displayed.

trim():-Used to trim or remove the particular character from the given string.
Syntax: trim(leading/trailing/both 'char' from string)

ex:- select trim(leading 'P' from 'PPT') from dual;
o/p- T
ex2:- select trim(trailing 'M' from 'ADAM') from emp;
o/p- ADA
ex3:- select trim(both 'P' from 'POPP') from dual;
o/p- O

replace():- Used to replace the given string.
Syntax:- replace(arg1,arg2,arg3)
arg1- main string
arg2- search string
arg3- replace string
NOTE: If you dont pass the 3rd argumrnt, 3nd argument(search string) will removed from the main string(1st arg).

Q1)WAQTD employee name also display if the employee name contains character 'R' replace with it 'D'.
Q2)WAQTD the no of character 'A' present in the employee name.
Q3)WAQTD employee name and job also replace the character 'K' from job to character 'MMM'.
Q4)WAQTD employee name also remove the character 'A' from all the employee names in deptno 10 or 20.
o/p- 8 rows selected
Q5)WAQTD no of 'M' present in your name.
Q6)WAQTD employee name and job, also replace the character 'D' to 'Z' from all job only for thoes whoe's mgr is 7788 or 7839.

translate(): It used to replace the given string, but it replace character by character.
Syntax: translate(arg1,arg2,arg3)
arg1:main string
arg2:search string
arg3:replace string

ex: select translate('SMITHA','S','Z') from dual; -> ZMITHA
	select translate('SMITHA','S',' ') from dual; ->  MITHA
	select translate('SMITHA','SA','Z') from dual; -> ZMITH
	select translate('SMITHA','SA','YZ') from dual; -> YMITHZ
	select translate('SMITHA','SMT','HK') from dual; -> HKIHA

Q1)WAQTD only consonants from employee names.
Q2)WAQTD only vowel from the employee names and all  pther character filled with space.


instr:- Dsiplay the position of the character, it returns the index values of particular occurence.
Syntax: instr(main-string, search-string, starting-index, no. of occurance)

Q1)WAQTD ename if the employee name contains at least 1 'A'.
Q2)WAQTD ename if the employee name contains at least 3 'S' in their their names.
Q3) input:- ravi output:-2
o/p- select instr('ravi','a',1,1) from dual;
Q4) input:- vanivilas output:-6
ans- select instr('vanivilas','i',1,2) from dual;
Q5)WAQTD ename,job and hiredate if the job contains at least 2 'K'.
Q6)WAQTD employee name, if employee


1)add_months:- It will add the months to the given date.
Syntax: add_months(arg1,arg2)
arg1- date
arg2- how many months to be added(in number)

Q1)WAQTD ename and hiredate along with add 12 months to the hiredate and display it.
ans- select ename, hiredate,add_months(hiredate,12) from emp;

Q2)WAQTD the current date after 5 years.
Q3)WAQTD ename,hiredate, and job display the hiredate after two years.
Q4)WAQTD ename,hiredate also display the hiredate before 3 years.

months_between:- Used to display the difference between the given dates.
Syntax: months_between(arg1.arg2)
arg1,arg2 :- date

Q1)WAQTD ename,hiredate and experience of the employee for all the employee.
ans- select ename,hiredate,round(months_between(current_date,hiredate)/12) as exp from emp;

Q2)WAQTD ename,hiredate and experience of the employee if the experience of the employee is more than 40 years.
Q3)WAQTD student name and age of the student.
Q4)WAQTD student name and age if the age is more than 25.
Q5)Find the difference from current date to '01-JAN-80'(yrs).
last_day:- It display the last date of the given date.
Syntax: last_day(arg1)

Q1)WAQT find the last date from the current_date date.
ans- select last_day (current_date) from dual;

Q2)WAQT find the last day of the next month.
Q3)WAQT find the first day of the next month.
Q4)WAQT find first day and last day of previous month.
Q5)WAQT find the last day of 23-FEB-2004.

Extract :-
Used to extract the month or year or date from the given date.
Syntax: extract(day/month/year from current_date/sysdate/hiredate/...)

Q1)WAQT extract the month where SMITH is hired.
ans- select extract (month from hiredate) from emp 
	 where ename='SMITH' ;

Q2)WAQT extract the year where ALLEN is hired.
Q3)WAQT extract the date where KING and SCOTT is hired, if they work in deptno 10/20/30 and if their length of the name is 4.
Q4)WAQT extract the month for all the employee.
Q5)WAQTD ename,hiredate and extract the date where employees are hired.
Q6)WAQT extract year from '12-JAN-2003'.
SPECIAL Function:-
------------------
General SRF:- nvl,nvl2(NULL VALUE LOGIC)

1)nvl():- Used to replce a value of null.
-Used to overcome the drawback null values.
Syntax: nvl(arg1,arg2)
-If the arg1 is null it substitutes the 2nd arg else it substitutes the same 1st argument.

Q1)WAQTD ename, sal,comm and total salary for all the employee.
ans- select ename,sal,comm,sal+nvl(comm,0) from emp; 

2)nvl2():-Used to overcome the drawback null values.
Syntax:nvl2(arg1,arg2,arg3)
-If the arg1 is null it substitutes 3rd argument.
-If the arg1 is not null it substitutes 2nd argument.

Q1)WAQTD ename,comm also if the employee earn comm display as 'earning comm' else display 'no commision'.
ans- select ename,comm,nvl2(comm,'earn comm','no comm') from emp;

Convertion srf:- to_char
1)to_char():- Used to convert the date type into date string.
Syntax: to_char(arg1,arg2)
 arg1:- date
 arg2:- 'date format'
 
Date format:-
d:- 1,2,3,4,5,6,7(sunday-1,monday-2,.....)
dy:- sun,mon,tue,wed,....
dd:- date (4-apr-23 -->4)
day:- monday,tuesday,wednesday,.....
mm:- month in number (jan-1, feb-2, .....)
mon:- 1st three character of the month (JAN,FEB,MAR.....) 
month:- january,frbruary,march.....
y:- (2023)-->3
yy:- (2023)-->23
yyy:- (2023)-->023
yyyy:- 2023
year:- twenty twenty three
HH12:- 12 hour format
HH24:- 24 hour format
MI:- minutes
SS:- seconds

Q1)WAQTD today's day.
ans- select to_char(current_date,'DAY') from dual;

Q2)WAQTD employee name and hiredate, also extract day from all the employees hiredate.
select ename, hiredate, to_char(hiredate, 'day') as day from emp;

Q3)WAQTD employee name and hiredate, if employee hired on THURSDAY.
select ename, hiredate from emp
where to_char(hiredate, 'FMDAY') = 'THURSDAY';

Q4)WAQTD employee name and hiredate if employee hired on december.
select ename, hiredate from emp
where to_char(hiredate, 'fmmonth') = 'december';

Q5)WAQTD employee name and hiredate , if employee hired on 20th.
Q6)WAQTD employee name and hiredate, if the reverse of month 4th character is vowel.
Q7)WAQTD employee name and hiredate, if the month of the 3rd character is same as their day 3rd character.
Q8)WAQTD employee name and hiredate, if employee hired in year nineteen eight.
NOTE:- FILL MODE used to fill space to complete the length.

to_date: Used to convert date string to date type.
to_date(arg1,arg2) -->(datestring,format of date string)

ex:- select to_date('12:SEP:2023','DD:MON:YYYY') from dual;

Multi Row Functions:- (MRF)
max():-
1) WAQTD maximum salary if emp is working in dept 10 or 20 also working as a SALESMAN.
select max(sal) from emp
where deptno in (20, 30) and job = 'SALESMAN';

2) WAQTD max sal if emp earning some commision also working as SALESMAN.
select max(sal) from emp
where comm > 0 and job = 'SALESMAN';

3) WAQTD max sal if emp earns commision more than 1000 and hired on thursday
select max(sal) from emp
where comm > 1000 and to_char(hiredate, 'fmday') = 'THURSDAY';

min():-It is used to display the minimum values given to specified column.
Syntax: min(arg1)

Q1)WAQTD minimum salary given to dept 10.
ans- select min(sal) from emp where deptno=10;

Q2)WAQTD minimum salary given to SALESMAN if they work in deptno 30 or 20.
select min(sal) from emp
where job ='SALESMAN' and deptno in (20, 30);

Q3)WAQTD minimum salary if the employee name starts with vowels and work in deptno 10 or 20.
Q4)WAQTD minimum salary given to clerk who works in deptno 10 or 30.
Q5)WAQTD minimum salary who works in deptno 30 as manager.


sum():- It is used to obtain the total value for specified column.
Syntax: sum(arg1)

Q1)WAQTD total salary given to all employee.
ans- select sum(sal) from emp;

Q2)WAQTD total salary given to employee who works as CLERK.
select sum(sal) from emp
where job = 'CLERK';

Q3)WAQTD total salary given to employee who works in deptno 20 or 30.

Q4)WAQTD total salary given to employees whoes name ends with vowels and also work as CLERK or manager in deptno 10 or 20 or 30.
select sum(sal) from emp
where substr(ename, -1,1) in ('A','E','I','O','U') and job in ('CLERK', 'MANAGER') and deptno in (10,20,30);

Q5)WAQTD total salary given to dept 20.

avg:- Used to obtain the average value of specified column.
Syntax: avg(arg1)

Q1)WAQTD average salary given to all employee.
ans- select avg(sal) from emp;

Q2)WAQTD average salary given to employee those who works in deptno 20.
select avg(sal) from emp
where deptno = 20;

Q3)WAQTD average salary given to manager.
Q4)WAQTD average salary given to clerk in deptno 10.

count():- It is used to obtain no of values present in specifed column.
Syntax: count(arg1/*)
Note:- count() is only mrf() which takes * as an argument.

Q1)WAQTD no. of employees present in the table.
ans- select count(*) from emp;

Q2)WAQTD no. of employees working as clerk.
select count(*) from emp
where job = 'CLERK';

Q3)WAQTD no. of employees working in deptno 10.
Q4)WAQTD no. of employees name starting with consonants.
select count(*) from emp
where substr(ename, 1,1) not in ('A','E','I','O','U');

Q5)WAQTD no. of employees hired in 03-DEC-81.
Q6)WAQTD no. of employees working as manager in deptno 10 or 30.
Q7)WAQTD no. of unique salary present in the table.
Q8)Calculate the diffrence of number of jobs with number of distinct job.
Q9)WAQTD maximum salary, minimum salary, total salary, average salary of salesman along with number of employee working as salesman.
select max(sal), min(sal), sum(sal), avg(sal), count(*) from emp
where job = 'SALESMAN' ;

Q10)WAQTD number of employees earning commision as analyst.

Group By Clause:-
-Used to group the records.
-After group by, any clause that executes, it executes group by group.
-The column-name or expresion which is written in group by clause can be included in select clause with group function(mrf()).
-It takes group of rows, if it finds common value it will be group to one.

Syntax: select group-function/group by expresion
		from table-name
		where <condition>
		group by expresion;
Order of execution: 1)from
					2)where(executes row by row)
					3)group by
					4)select(executes group by group)

Q1)WAQTD maximum salary given to each dept. 
select max(sal) from emp
group by deptno;

Q2)WAQTD minimum salary given to each dept. 
Q3)WAQTD maximum salary given to each job if the employee works in deptno 10 or 20. 
select max(sal), job from emp
where deptno in (10,20) 
group by job;

Q4)WAQTD minimum salary given to each job if the employee who dont earn any commision.
select min(sal), job 
from emp
where comm is null 
group by job;

Q5)WAQTD total salary given to each dept if the employee works as clerk. 
Q6)WAQTD total salary given to each job. 
Q7)WAQTD average salary given to each job, if the employee works in dept 10 or 20. 
select avg(sal), job from emp
where deptno in (10,20) 
group by job;

Q8)WAQTD no. of employees working in each dept.
Q9)WAQTD no. of employees working in each job.
Q10)WAQTD no. of employees working in each dept as clerk or manager.
Q11)WAQTD no. of times the salary present.
Q12)WAQTD no. of times the employee name is present.
Q13)WAQTD no. of employees earning some salary in each job and also have reporting manager.
select count(*), job from emp
where sal >0 and mgr is not null
group by job;

Q14)WAQTD no. of employees working in each dept, if the name last 2nd character is R.
select count(*), deptno from emp
where substr(ename, -2,1) = 'R'
group by deptno;

Q15)WAQTD no. of employee working in each dept if the employees names ends with consonants.
select count(*) as total, deptno from emp
where substr(ename, 1,1) not in ('A','E','I','O','U')
group by deptno;

# having clause:- Used to filter the groups.
-having clause is written after the group by clause.
-We can use having clause to write the condition based on group function/multi-row-function/aggregate function.
Syntax: select gf/group by expresion  -->5 (group by group)
		from table-name               -->1 
		where <condition> 			  -->2 (row by row)
		group by expresion 			  -->3 
		having <condition>; 		  -->4 (group by group)
		
diffrence between where and having:
1)where : It is used to filter records.
-It executes row by row.
-We cant use mrf() in where clause.
-Where clause is implimented on rows.
-We write where clause before group by clause.
-We can use where clause without using group by group clause.

2)having: It is used to filter the group.
-It executes based on group by output(group by group).
-We can use mrf() in having clause.
-Having clause is executed on columns.
-It is written after group by clause.
-We should use having clause after group by clause, if there is no group by clause there will be no meaning for having clause.

Q1)WAQTD no. of employees working in each dept display if at least 2 employee working in each dept.
select count(*), deptno from emp
group by deptno
having count(*) > 4;
	 
Q2)WAQTD no. of employees working in each job if at least 3 employee working in each job.
select count(*), job from emp
group by job
having count(*) > 3;
	 
Q3)WAQTD salary that are repeated.
select sal from emp
group by sal
having count(*)>1;
	 
Q4)WAQTD employee name which is repeated.
select ename from emp
group by ename
having count(*)>1;

Q5)WAQTD no. of employees with dept no if employee working in each dept if there atleast 2 clerk in each dept .
select count(*), deptno from emp
where job = 'CLERK'
group by deptno
having count(*)>=2;
	 
Q6)WAQTD total salary neded to pay all the employees if there are atleast 4 employee in each dept.
select sum(sal), deptno  from emp
group by deptno
having count(*)>4;

Q7)WAQTD no. of employee earning salary more 1200 in each job and total salary neded to pay  all the employee for each job must exceed 3800.
select count(*), job from emp
where sal>1200 
group by job
having sum(sal)>3800 ;
	 
Q8)WAQTD deptno and no of employee working in each dept if there exactly 2 employee working in each dept as ANALYST.
	 
Q9)WAQTD minimum and maximum salaries of each job if minimum salary is more than 1000 and maximum salary is less than 5000.
	 
Q10)WAQTD average salary of each dept if average salary is less than 3000 and maximum salary exceeds 2600.
	 
Q11)WAQTD hiredate which are duplicated in emp table.
select hiredate from emp
group by hiredate
having count(*)>1;

Q12)Display the deptno and salary, if employee earn same salary in same dept.
select deptno, sal from emp
group by sal, deptno 
having count(*)>1;

Q13)Display the job,sal and deptno, if employee work in same job with same salary and same dept.
select job, sal, deptno from emp
group by job, sal, deptno
having count(*)>1;

Order by clause:
-Used to sort the data according to asc or desc.
-By default order by clause helps to sort in acs order.
-We can pass more than one column in order by clause, always 1st preference give to the 1st column.
-Instead of passing the column-name we can also sort by using the column-number.

Syntax: select */distinct(col-name)
		from table-name
		order by col-1,col-2......  asc/desc;
		
order of execution: 1)from  2)distinct   3)select   4)order by

Syntax-2: select gf/group by expresion
		  from table-name
		  where <condition>
		  group by column-name
		  having <condition>
		  order by col-1,col-2......  asc/desc;
		  
order of execution: 1)from  2)where  3)group by  4)having  5)select  6)order by

Q1)WAQTD details of employee and also display the salary according to lowest to highest.
ans- select * from emp
	 order by sal;
	 
Q2)WAQTD details of employee and also display the ename according to desc order.
ans- select * from emp
	 order by ename desc;
	 
Q3)WAQTD details of employee and also sort according to the latest hiredate at the first row.
ans- select * from emp
	 order by hiredate desc;
	 
Q4)WAQTD details of employee and also sort the hiredate according to asc order.
ans- select * from emp 
	 order by hiredate;
	 
Q5)WAQTD repeated salary and sort the salary according to asc order. 
ans- select sal from emp
	 group by sal
	 having count(*)>1
	 order by sal;
	 
Q6)WAQTD no of employee working in each job, also sort according to no of employee in desc order.
ans- select count(*), job from emp
	group by job
	 order by count(*) desc;

Q7)WAQTD no of employee working in each department in desc order.
ans- select count(*), deptno from emp
	group by deptno
	order by count(*) desc;
	 
Q8)WAQTD no of emp working under each manager in asc order
ans- select count(*), mgr from emp
	group by mgr
	order by count(*);
	 
Subquery:-
-The query which is written inside the parenthesis will be identified as subqueries.
-A query which is written inside another query is called subquery.
-There are two main queries :-
		1)Outer/Main query
		2)Inner/Sub query
Workflow:
step1:- subquery gets executed 1st and produce some output.
step2:- output of sub-query given as input of the main query and then main query gets executed.
step3:- after execution of the outer-query it produce complete result.

Syntax: select gf/group by exp
		from table-name
		where col-name (=/in) (select group by exp/col-name
							   from table-name where <condition>
							   group by exp
							   having <condition>)
		group by col-n
		having <condition>
		order by col-name;

**-> Order by clause cannot be used in sub-query.

Types of sub-query:-
1)Single Row Subquery
2)Multi Row Subquery
3)Nested Subquery
4)Inline Subquery
5)Co-related Subquery

1)Single Row Subquery:- If the sub-query return exactly one output/value is known as Single Row Subquery.
- It supports both relational(<,>,<=,>=,=,!=) and special(in,not in) operator.

2)Multi Row Subquery:- If the sub-query return more than one output/value will be known as Multi Row Subquery.
- It supports special operator(in,not in) as well as (ANY and ALL operator).

When to use sub-query ?
Case-1: 
When unknown is present in the question we need to use sub-query.

Case-2:
Display the data from one table but condition base on another table.

Case-3:
Nested query or consition(min/max)

Case-4:
ALL/ANY scenario

Case-5:
Based on relation value; e.g- employee manager relation



Case-1:-
Q1)WAQTD employee details if employee is working in same dept as ALLEN.
ans- select * from emp 
	where deptno=(select deptno from emp 
				where ename='ALLEN');

Q2)WAQTD employee details if employee working in same designation where Miller is working.
ans- select * from emp 
	where job=(select job from emp 
			where ename='MILLER');

Q3)WAQTD employee name and hiredate if employee hired in the same date where JONES is hired.
ans- select ename, hiredate from emp 
	where hiredate=(select hiredate from emp 
					where ename='JONES');

Q4)WAQTD ename,sal and deptno if employee earning same as SCOTT if they work in dept 10 or 20 and name start with vowel.
ans- select ename, sal, deptno
	from emp
	where sal = (select sal from emp
				where ename='SCOTT') 
		and deptno in (10,20)
		and substr(ename, 1,1) in ('A', 'E', 'I', 'O', 'U');

Q) WAQTD the details of emp whose name starts with 'A' and works in the same department as BLAKE.
select * from emp
where ename like 'A%' and deptno = (select deptno from emp
									where ename = 'BLAKE');
									
Q)WAQTD ename, sal and designation of emp whose anual sal is more than SMITH and less than KING.
select ename, sal, job from emp
where (sal*12) > (select sal from emp where ename = 'SMITH')
	and (sal*12) < (select sal from emp where ename = 'KING');
	
Q)WAQTD no of emp earning more than SMITH and less than MARTIN and hired after JAMES and name ends with S and also earning some commision.
select count(*) from emp
where sal > (select sal from emp where ename='SMITH')
	and sal < (select sal from emp where ename = 'MARTIN')
	and hiredate > (select hiredate from emp where ename='JAMES')
	and ename like '%S' and comm is not null;
	
Case 2:-
Q)WAQTD emp details who are working in New York.
select * from emp
where deptno = (select deptno from dept where loc = 'NEW YORK');

Q)WAQTD dept name of emp who are working as CLERK.
select dname from dept 
where deptno in (select deptno from emp
				where job = 'CLERK');

Q)WAQTD dept details if the emp earning more than 2000
select * from dept 
where deptno in (select deptno from emp where sal>2000);

Q)WAQTD dept details if the emp earning more than 2000 but less than KING
select * from dept 
where deptno in (select deptno from emp where sal>2000
	and sal< (select sal from emp where ename='KING'));
	
Case 3:-
select * from emp
where sal = (select max(sal) from emp);

select * from emp
where sal = (select min(sal) from emp);

Q)WAQTD 2nd maximum sal
select max(sal) from emp
where sal < (select max(sal) from emp);

Q)WAQTD details of emp getting 3rd max sal.
select * from emp 
where sal = (select max(sal) from emp
where sal < (select max(sal) from emp 
where sal < (select max(sal) from emp)));

Q) Display department details of emp if getting highest sal
select * from dept
where deptno = (select deptno from emp 
where sal = (select max(sal) from emp));

Q)Display details of the emp who got hired as last emp
select * from emp
where hiredate = (select max(hiredate) from emp);



Joins:-
1)Inner Join/EQUI Join
2)Outer Join
	-Left Outer Join
	-Right Outer Join
	-Full Outer Join
3)Cross Join
4)Natural Join
5)Self Join

1)Inner Join
Oracle-Syntax:
select */column-name
from table1, table2
where join-condition;

ANSI-Syntax:
select */column-name
from table1 inner join table 2
on join-condition;

Q)Display all details from both emp and dept table
select * 
from emp, dept
where emp.deptno = dept.deptno;

select * 
from emp inner join dept
on emp.deptno = dept.deptno;

Q)Display emp name and dept name
select ename, dname
from emp, dept
where emp.deptno = dept.deptno;

select ename, dname
from emp inner join dept
on emp.deptno = dept.deptno;

Q)Display ename, dname if emp name start from A
select ename, dname
from emp, dept
where emp.deptno= dept.deptno and 
	ename like 'A%';
	
2)Outer Join
a)Left Outer Join
Oracle-Syntax:
select */column-name
from table1, table2
where join condition (+);

ANSI-Syntax:
select */column-name
from table1 left outer join table2
on join-condition;

Q)Display ename and their dname and also display the empname if emp not working in any dept.
select ename, dname 
from emp, dept
where emp.deptno = dept.deptno (+);

select ename, dname 
from emp left outer join dept
on emp.deptno = dept.deptno;

b)Right Outer Join
Oracle-Syntax:
select */column-name
from table1, table2
where (+) join-condition;

ANSI-Syntax:
select */column-name
from table1 right outer join table2
on join-condition;

Q)Display ename and their dname also display the deptname if no emp is working in that dept.
select ename, dname 
from emp, dept
where emp.deptno(+) = dept.deptno;

select ename, dname 
from emp right outer join dept
on emp.deptno = dept.deptno;

c)Full Outer Join
ANSI-Syntax:
select */column-name
from table1 full outer join table2
on join-condition;

Q)Display ename, dname also display the ename if emp don't work in any dept also include deptname if no emp is working in the dept.
select ename, dname
from emp full outer join dept
on emp.deptno=dept.deptno;

3)Cross Join
Oracle-Syntax:
select */column-name
from table1, table2, table3...;

ANSI-Syntax:
select */column-name
from table1 cross join table2 cross join table3.....;

Q)Display ename and dname for each table.
select ename, dname 
from emp, dept;

select ename, dname
from emp cross join dept;

Q)Display ename, dname, hisal for each table
select ename, dname, hisal
from emp, dept, salgrade;

select ename, dname, hisal
from emp cross join dept cross join salgrade;

4)Natural Join
ANSI-Syntax:
select */column-name 
from table1 natural join table2 natural join table3..;

ex: select ename, dname 
	from emp natural join dept;
	
ex: select ename, hisal
	from emp natural join salgrade;
	
5) Self Join
Oracle-Syntax:
select */column-name
from table1, table2
where join-condition;

ANSI-Syntax:
select */column-name
from table1 join table2
on join-condition;

Q)Display emp name and his manages name.
select e.ename, m.ename
from emp e, emp m
where e.mgr = m.empno;

Q)Display ename and his manager name and his manager name.
select e.ename, m1.ename, m2.ename
from emp e, emp m1, emp m2
where e.mgr = m1.empno and
m1.mgr = m2.empno;